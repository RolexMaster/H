레거시 방식(ProcessGfeMsg)과 DDS 방식(on_data_available) 간의 구조적 차이를 정량적으로 분석하기 위해,
각 함수의 **사이클로매틱 복잡도(Cyclomatic Complexity, CC)**와 **코드 라인 수(LOC)**를 측정하였다.
양측 모두 동일한 조건을 유지하기 위해, 동일한 메시지 포맷(그림 X 참조)을 수신 처리하는 과정을 구현한 코드를 비교 대상으로 하였다.


두 지표는 서로 독립적인 분석 기준이지만, 일반적으로 복잡도가 높을수록 코드 라인 수 역시 증가하는 경향이 있다.
레거시 방식은 패킷의 헤더를 먼저 수신하여 메시지 번호와 전체 길이를 파악한 뒤,
그 길이에 맞춰 다시 전체 바디를 수신하는 2단계 파싱 구조를 따른다. 이 과정은 조건 분기, 유효성 검사, 예외 처리, 버퍼 정리 등의
복잡한 제어 흐름을 포함하며, 코드의 테스트 경로 수와 유지보수 부담을 동시에 증가시킨다.

반면, DDS 기반 구현은 IDL(Interface Definition Language)을 기반으로 정의된 메시지 구조체 형태로 데이터를 자동 수신하며,
take_next_sample() 호출 시 이미 역직렬화된 객체로 전달된다. 또한, DDS는 각 샘플에 대해 SampleInfo.valid_data를 통해
데이터 유효성 여부를 함께 제공하므로, 개발자는 필요한 경우에만 비즈니스 로직 수준의 추가 유효성 검사만 구현하면 된다.

이러한 구조적 차이는 그림 X의 플로우차트에서도 명확하게 나타난다.

**레거시 방식 (그림 X-a)**은 헤더 확인 → 유효성 검사 → 바디 재수신 → 메시지 번호 분기 → 구조체 파싱 등의
복잡한 흐름과 조건 분기를 포함하며, 총 CC 8의 높은 복잡도를 가진다.

**DDS 방식 (그림 X-b)**은 Topic 이름 확인 → 샘플 수신 → 유효성 확인 → 처리로 이어지는
단순하고 일관된 제어 흐름으로, 복잡도가 절반 이하로 감소하였다.

결론적으로, 동일한 메시지 포맷을 처리함에도 불구하고,
DDS 기반 구현은 구조적 복잡도를 낮추고 코드량을 줄이며, 개발자가 메시지 해석에 들이는 부담을 현저히 경감시킨다.
이는 유지보수성, 확장성, 테스트 용이성 향상에 있어 DDS 방식이 실질적인 효과를 갖는다는 점을 실증적으로 보여준다.
